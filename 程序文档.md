# 文档


这是一个哥德尔编码器的配套文档。（下文主要概念应该都可以在各种百科里搜到，就不贴链接了）

## 前序表达式

常见的四则运算一般把运算符放在两个作用对象之间，称为中序表达式。

**前序表达式（波兰式）** 是另一种书写数学表达式的规则，也就是把运算符（+、-、*、not）放在对应作用对象（1、2、true）的前面。

> **例子：** 1+1是一个普通的（中序）加法算式，而+ 1 1（注意空格）则是它的前序表达式版本；同理，(1+1)×2对应× + 1 1 2。前序表达式也有带括号的版本，比如上述例子可以表述为(+ 1 1)和(* (+ 1 1) 2)。某种意义上编程语言的大多数函数也是前序表达式。

前序表达式（和它的兄弟逆序表达式）的优点在于可以省略括号而不产生歧义 ~~（缺点是需要空格）~~，示例参见[逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)和科普博客等。

## 哥德尔编码

### 自然数的数论表达

习惯上，自然数用十个数码（0-9）的组合来表示。在数论当中，出于希望简省符号的目的，可以采用递推的方式表达自然数（‘S’是successor的简写，即下一个自然数，程序中写作‘next’）：

| **数码表达** | **数论表达** | **<span id="expression">程序表达</span>** |
| ---- | ----- | ------ |
| 0 | ‘0’ | '0' |
| 1 |‘S0’ | '( next 0 )' |
| 2 | ‘S1’=‘SS0’ | '( next ( next 0 ) )' |
| ... | ... | ... |

这样我们就用两种符号表达了所有自然数！~~（好像也没什么可惊讶的）~~

### 哥德尔编码

哥德尔编码是一套把数学表达式表达为自然数的编码方式。步骤如下：

1. 按照以下符号映射（来自[这里](https://stopa.io/post/269)，有修改）将组成表达式的<font color=red>数学符号</font>表示为一列<font color=green id="sym_num">自然数</font>。表达式中<font color=red>作为数学符号的自然数</font>先表达为程序表达再转化为<font color=green>自然数</font>；

<span id="符号映射">符号映射表</span>

   | <font color=red>**数学符号**</font> | <font color=green>**自然数**</font> |
| ------------------ | ------------------------- |
| (                | 1                       |
| )                | 3                       |
| 0                | 5                       |
| next             | 7                       |
| +                | 9                       |
| *                | 11                      |
| =                | 13                      |
| not              | 15                      |
| or               | 17                      |
| when             | 19                      |
| there-is         | 21                      |
| a                | 2                       |
| b                | 4                       |
| c                | 6                       |
| subst            | 10                      |
| proves           | 20                      |
| ...              | ...                     | 
   
2. 对表达式的每一个符号，将第i个<font color=red>数学符号</font>表示为第i个<font color=orange>质数</font>的<font color=green>自然数</font>次幂；
3. 将所有幂乘起来。

> **例子：** 第一步，把“+ 0 0”表示为“9 5 5”；
> 
> 第二步，找到对应的第1、2、3个质数（分别是2、3、5）并求出幂，2^9=512，3^5=243，5^5=3125；
> 
> 第三步，求出所有幂的乘积512 x 243 x 3125=388800000。

程序示例如下。（程序规范见后）

```bash
input the expression ('q' or empty line to quit):
+ 0 0
the result is: 388800000
```


**动动手：** 现在你已经掌握了哥德尔编码的方式，请写出( = ( + 1 5 ) 6 )的编码吧！<font color=#DCDCDC>（<span id="answer">答案</a>见文末）</font>

## 程序功能概要

本程序是一个哥德尔编码器，输入一行在符号表上的<font color=red>符号</font>或者一个自然数、“L”+自然数、“X”+自然数，每个<font color=red>符号</font>之间以空格分隔，输出一个对应的哥德尔数。用户输入的除了0以外的自然数，先经过预处理为[自然数的程序表达](#expression)，注意程序表达是带括号的前缀表达式。

对于多行的输入，程序支持通过回溯获得前几行输入的公式（L模式）和对应的哥德尔数（X模式）。例如，对于如下多行公式（以下以$表示输入的内容，程序中没有回显；以exe表示本程序）：

```bash
> exe
input the expression ('q' or empty line to quit):
$ = 0 0
the result is: 6220800000
input the expression ('q' or empty line to quit):
$ not L0
the result is: 2743888554086400000
input the expression ('q' or empty line to quit):
$ = X1 0
^C
```
程序示例 *（请避免像这样输入X表达式，可以思考一下为什么）*
第二行中L0被直接替换为（不包含自身）向上数第0行对应的公式（“= 0 0”），所获得的哥德尔数就是“not = 0 0”对应的哥德尔数。

第三行中的X1则找到向上数第1行对应的公式（仍然是“= 0 0”），找到对应的哥德尔数并把它~~转换为字符串再~~转换为数论表达填入，所获得的哥德尔数就是“= 6220800000 0”对应的哥德尔数。

（为什么L和X后写的是回溯的行数而不是绝对行数呢，是因为 ~~*偷懒用了LISP的栈数据结构*~~ 容易查找）

### 输入方式

程序模式支持通过命令行从不同位置读入数据。

#### 文件模式

输入文件路径参数，如果指向一个UTF-8文本，则分行读取每一行的公式。输出是最后一行的哥德尔数。

```bash
> cat data
= 0 0
> exe data
6220800000
```

#### 交互模式

不输入文件路径参数。运行后分行输入每一行的公式，在每一行后都会打印对应的哥德尔数。空行或Ctrl-C退出交互模式。退出时仍重复显示最后一次输出。

```bash
> exe
input the expression ('q' or empty line to quit):
$ = 0 0
the result is: 6220800000
input the expression ('q' or empty line to quit):

6220800000
```

### 教程模式

除了上述功能，为了便于初学者了解程序的操作，还内置了交互式的教程模式，输入-t参数进入。教程模式的最终输出是对最后一句语句的[求值](#usage)。

```bash
> exe -t
input an expression among "0", "next <number>", "+ <number1> <number2>" or "* <number1> <number2>":
$ next 1
input an operator among "= L0 <number>", "= X0 <number>" or "= L0 X0":
$ = L0 1
input an operator among "proves 1 X0", "not L0" or "proves X0 X0":
$ proves X0 X0
the result is: true
```

### 数据存储方式

程序默认（-n，--output-numbering）把每一行转化为对应的哥德尔数存储。由于某些公式的哥德尔数很大，难以存储对应的数字，所以对于这类公式请采用-e或--output-evaluation参数，程序需要以列表而非数字方式存储和输出。-e模式的输出是对相应语句的[求值](#usage)。

```bash
> exe -n
input the expression ('q' or empty line to quit):
$ 4
the result is: 3084113413209534468257782491998238801561737858275559610

...

> exe -e
input the expression ('q' or empty line to quit):
$ 4
the result is: next next next next 0
input the expression ('q' or empty line to quit):
$ X0
the result is: <the Gödel number of:
        next  next  next  next 0
  >
```

其中the Gödel number of: ...表示这是一个哥德尔数，对应的公式是next next next 0，而它本身的表达是next next ...（一共3084113413209534468257782491998238801561737858275559610个next） next 0，在程序中理应存储的数字则是后者对应的哥德尔数。

![两次解释](./double_encode.svg)

### 帮助模式

以-h唤出。

## 测试内容

由于作者的一些疏忽🥲，程序运行可能并不完全符合上面的说明。请使用者根据一些信息对程序进行黑盒测试，找出出现问题的具体场景和表现。

已知：

1. 在教程模式中，是否带-e参数和3次输入中的某个组合（包括3次输入内的组合），可能引起问题；
2. 输入长度超过大约20时可能会产生一些未定义行为；
3. （附加题）在-e模式下，可以构造[quine](#quine)表达式。但是由于本程序的求值功能有限，有可能产生意外的功能……

程序遇到部分上述问题会以中文显示。
其他问题也欢迎在错误报告中指出。

## 作业提交内容

测试报告文档 + 展示材料（ppt等）。

报告文档格式要求易读，结构清晰完整，可以采取压缩包形式以包含必要的附件，篇幅建议不超过 **3页** 。展示材料以清晰地说明问题为第一要义，趣味性、交互性、格式多样性等 **有可能** 获得加分。
两部分材料都应当至少包含以下要点。

### 设计方案

请写出测试用例的设计思路和原因，体现了什么样的测试思想。

### 测试用例

请以易读的方式列举所有或部分重要的测试用例，必要时可以呈现或附上相关的代码。

### 结果分析

请尽可能报告测试用例得到的重要输出结果，并分析程序可能存在的问题和测试用例如何完成测试任务。

### 其他（可选）

可以附上测试中的感悟、吐槽、问题反馈，对作业和授课方式的思考和期望等。

## 补充阅读

### 编码/表达

文档所有的“表达为”，都应该理解为一种可逆的编码。编码前后的信息是相等的，正如压缩前后的信息是相等的<font color=green>~~（咦，那为什么占的空间不一样大）~~</font>。任何对编码前的信息的判断，都适用于编码后的<font color=green>~~（唔，显然不包括对占用空间的判断）~~</font>。

> **例子：** Morse码说的.../-/---/-./.和英语里的“stone”传递了相同的信息。中英翻译不严格是可逆的，但也可以看作是编码。

### 说谎者悖论

说谎者悖论be like

“这行句子是假的。”

它涉及[自我指涉](https://zhuanlan.zhihu.com/p/58822501)的问题，因此无法从简单的逻辑体系说明它的真假。一旦假设了它的真假，就会推出相反的结论。现行的数学和逻辑体系尽可能地避免说谎者悖论的出现。

### 哥德尔的思路

是哥德尔不完备性定理的重要组成构件，本质上是个说谎者悖论。哥德尔的主要贡献就是证明说谎者悖论在很简单的逻辑体系中都可以构造出来，从而破灭了创建完备逻辑体系的神话。

而这种构造方法用了**哥德尔编码**，以及[Quine](https://lifegoo.pluskid.org/wiki/Quine.html)。

以下不严谨地简述不完备性定理的构造思路。

#### <font color=green>可以被证明</font>和<font color=orange>是真的</font>

首先要说明什么是<font color=green>可以被证明</font>。

1. <font color=green>可以被证明</font>是一个类似于[proves函数](https://stopa.io/post/269)的谓词。proves可以被程序定义 ~~（虽然计算量极大）~~。
2. <font color=green>可以被证明</font>只是描述了某个[证明系统的能力](https://math.stackexchange.com/questions/69353/true-vs-provable/69362#69362)。

哥德尔编码说明了数学表达式都可以无损地对应到自然数中，一个<font color=red>表达式Q</font><font color=green>可以被证明</font>对应了它对应<font color=blue>自然数q</font>的一个性质<font color=red>P</font><font color=blue>q</font><font color=orange>是真的</font>。（一个自然数的性质也是一个表达式）

![可证明性的性质](./provables.svg)

在哥德尔前的探索者已经证明，“一个句子<font color=green>可以被证明</font>，它就（在特定的逻辑体系中）<font color=orange>是真的</font>”。这被称为一致性（consistency）。他们还希望证明另一个方向的命题，即“一个句子<font color=orange>是真的</font>，它就<font color=green>可以被证明</font>”，即完备性（completeness）。

```bash
> exe -e
input the expression ('q' or empty line to quit):
$ = 0 0
the result is: true （且可以被证明）
input the expression ('q' or empty line to quit):
$ proves 1 X0
the result is: true
```
上述代码片的含义参见[详细功能介绍](#usage)。

如果<font color=red>表达式not P</font><font color=blue>b</font>是<font color=green>可以被证明</font>的（因此<font color=orange>是真的</font>），那么<font color=blue>自然数b</font>对应的<font color=red>表达式B</font>就不<font color=green>可以被证明</font>。

根据可证明性质的定义，<font color=red>表达式not P</font><font color=blue>b</font>对应的<font color=blue>自然数npb</font>的性质<font color=red>P</font><font color=blue>npb</font><font color=orange>是真的</font>。

如果完备性成立，<font color=red>表达式not B</font><font color=orange>是真的</font>。

![循环](./loop.svg)

*<font color=grey>粉红圆形代表不可证明，绿圆形代表可以证明，橙方块表示是真的</font>*

如果<font color=red>P</font><font color=blue>npb</font>=<font color=red>B</font>呢？~~说谎者悖论产生了！~~ 为了不产生矛盾，需要使这个推理中至少有一处不成立，这就是不完备性的起源。

#### <span id=quine>Quine方法</span>

*（完了，剩下的部分是quine，如果我没讲清楚就请各位自行查阅资料吧）*

为了得到满足<font color=red>P</font><font color=blue>npb</font>=<font color=red>B</font>的语句，需要引入quine的概念。Quine是一类有意思的程序，它们的输出就是本身，例如这个[C程序](https://www.geeksforgeeks.org/quine-a-self-reproducing-program/)：

```C
main(a){printf(a="main(a){printf(a=%c%s%c,34,a,34);}",34,a,34);}
```
的输出就是它的源代码本身。

在我们的哥德尔编码器中，也可以使用[subst](#usage)构造出quine来。

```bash
input the expression ('q' or empty line to quit):
$ subst b 4 b
the result is: subst b 4 b
input the expression ('q' or empty line to quit):
$ subst X0 4 X0
```
subst b 4 b在这个编码器中的哥德尔数是9252156944359214315599423180365194028427122078099286502394821801530067266560（记作sb4b），所以它的第二句表达式实际上是subst sb4b 4 sb4b。而它的输出则会是subst sb4b 4 sb4b（的哥德尔数）。也就是输出了自己。

用类似的方法，就可以构造出上面的<font color=blue>B</font>，也就是哥德尔句子G了。

参考[What Gödel Discovered](https://stopa.io/post/269)和[哥德尔、艾舍尔、巴赫](https://book.douban.com/subject/1291204/)。

### LISP

LISP是一类函数式编程语言，有超过C语言的历史，其共同特点是前缀表达式、基于列表的数据结构、（几乎）可以更改关键词的宏和作为数据的函数 ~~（还有[括号](https://www.zhihu.com/question/64532732/answer/569561616)）~~。

LISP的一种分支clojure如下。
（改编自[Learn clojure in Y Minutes](https://learnxinyminutes.com/docs/clojure/)）

def将一个变量绑定到变量名上，注意函数也是变量，也可以用def绑定。

```clojure
$ (def x 1)
$ x
1
```

fn [] ...声明一个函数。在函数外套一对括号是对它求值，只有求值时函数的主体才会运行，否则只是函数变量。

```clojure
$ (fn [] "Hello World")
fn

$ ((fn [] "Hello World"))
"Hello World"

$ (def hello-world (fn [] "Hello World"))
$ (hello-world)
"Hello World"

$ hello-world
fn
$ ((hello-world))
???
```

因此在LISP中，括号的数量非常重要，决定了对函数的求值次数。

更多关于LISP的内容请查阅网上资料和SICP等。

<font color=green>（为什么有这一回呢，是因为我作死用LISP的另一种方言Racket写的程序【见下】）</font>

### <span id="usage">程序其他功能</span>

终于解除封印的哥德尔编码器拥有了更多的功能。现在，它支持-n（输出哥德尔数模式）和-e（输出表达式的值【实验版】）的参数。当然，在-e模式下输入的表达式必须是规范的。

<span id=format>程序求值的规则</span>如下。

| **原子表达式**   | **规则** |
|----------------|-----------------|
|\= number1 number2|是否相等|
|\+ number1 number2|和|
|\* number1 number2|积|
|next number1 | number1 + 1|
|not expr | expr的否定 |
|proves g1 g2 | g1对应的公式能否推出g2（有[缺陷](#prove_fault)） |
|subst g1 sym1 g2 | 把g1对应公式中的中sym1改为g2 |
|其他 |以列表原样输出|

其中number1、number2是自然数，expr是公式。g1、g2是公式的哥德尔数，sym1是<font color=red>符号</font>映射的[自然数](#sym_num)或公式的哥德尔数。

举例来说，想要陈述“一个公式= 1 1可以被无条件证明”，即对应的哥德尔数a能被空句子对应的哥德尔数1推出，则可以写：

```bash
input the expression ('q' or empty line to quit):
$ = 1 1
the result is: true
input the expression ('q' or empty line to quit):
$ proves 1 X0
the result is: true
```

当然本程序主体仍然只是个编码器，~~处理语义已经很费力气了~~。proves的语义有一定的[缺陷](#prove_fault)，在大多数场合都无法处理对应的句子。感兴趣的同学可以测试proves无法处理的情况并写到报告里。

subst的语法相对复杂一些。它接受一个哥德尔数A、一个<font color=red>符号</font>映射的自然数b和另一个哥德尔数C，将一个哥德尔数对应的公式中的b替换为C。（subst的实现和[What Gödel Discovered](https://stopa.io/post/269)中不同。有余力的同学可以思考为什么。）

```bash
input the expression ('q' or empty line to quit):
$ proves 1 b
the result is: proves 1 b
input the expression ('q' or empty line to quit):
$ = 0 0
the result is: true
input the expression ('q' or empty line to quit):
$ subst X1 4 X0
the result is: <the Gödel number of:
       proves  next 0  <the Gödel number of:
           = 0 0
      >
  >
```

### 多行表达式

程序鼓励使用多行表达式来书写证明，每一行仅需写一个原子表达式，较长的句子可以使用L回溯的方式进行组装。

```
input the expression ('q' or empty line to quit):
$ = a 0
the result is: = a 0
input the expression ('q' or empty line to quit):
$ there-is a L0
the result is: ∃ a = a 0
input the expression ('q' or empty line to quit):
$ not L0
the result is: not ∃ a = a 0
```

多行的另一个好处是可以不用直接书写一个表达式的哥德尔数，而是使用X回溯代替。

```
input the expression ('q' or empty line to quit):
$ = a 0
the result is: = a 0
input the expression ('q' or empty line to quit):
$ proves 1 X0
the result is: proves 1 <the Gödel number of:
       = a 0
  >
```

### 单行表达式

本质上单行表达式和多行表达式的表达能力是一样的。由于[已知问题](#improve)所述，目前只能使用带括号的前缀表达式书写较长的表达式。

```
input the expression ('q' or empty line to quit):
$ ( = ( + 1 2 ) 3 )
the result is: true
```


### 程序实现底层

这个程序是由[Racket](https://http://racket-lang.org/)（一种LISP方言）实现的，因此支持了大整数和跨平台虚拟机。

它的基础是[What Gödel Discovered](https://stopa.io/post/269)附的代码，实现了一个简单的哥德尔数和lisp表达式相互转换的功能。

```lisp
> (pm-lisp->godel-num (string-split "( = 0 0 )"))
222907450286193750
```

交互界面由`(require racket/cmdline)`实现，读取每一行交给解析器，产生一个上下文（对应本行的哥德尔数），以供未来进一步的解析和求值使用，解析器是parse函数，内置了把自然数变成"( next ... ( next 0 ) ... )"序列的预处理器和把序列转换为哥德尔数存入上下文的功能。

```lisp
> (car (parse '("0" "= L0 1") '()))
'(2900320447258853498880 32)
> 
```

解析器接受一个字符串列表和一个上下文参数，返回上下文和求值结果两个值。求值结果是最后一个表达式的值（如果能求出来的话）或者表达式的字面量（如果不能求出来）。

由于大整数的哥德尔编码会形成超过内存容量的整数，无法计算，所以在数值模式之外实现了用列表方式存储哥德尔编码的方式，对应另一个解析器函数parse/sal。它所要求的表达式需要满足一定的[格式](#format)。

```lisp
> (car (parse/sal '("= 0 0") '()))
'(#s(godel-number-of ("(" "=" "0" "0" ")")))
```



## <span id="improve">已知问题和改进方向</span>

除了程序测试可以覆盖的问题以外，程序还有些其他问题。

1. 程序目前需要在每一个表达式外套一对括号来辅助解析。如前所述，前缀表达式是可以不借助括号完成解析的。

2. 因为逻辑系统相对于程序来说仍然比较复杂，许多语义都还没有实现，所以proves<span id="prove_fault">只能处理很有限的句子</span>。

3. 需要对哥德尔数的整数、数论表达和列表存储做一个统一的抽象，否则相等判断会出问题。

## 附录

[哥德尔编码问题](#answer)的答案：324938917090805842564189032893510438300782287121030545217954774333657749858311121354093088727974403713795560308602807285731806148379615615765622337595371209490

## 参考

另一个好玩的逻辑问题，学有余力的同学可以看看（是不是看到这里的同学已经随便乱杀这个问题了）：[Lob定理的证明（觉得自己集合论学得好其实是一种幻觉……）_UNOboros的博客-CSDN博客](https://blog.csdn.net/UNOboros/article/details/50379333)

本次作业的出发点（上面已经引用过了），强烈建议阅读，说不定有惊喜：[What Gödel Discovered](https://stopa.io/post/269)

随机测试包含的[彩蛋](https://www.thevintagenews.com/2018/04/24/kurt-godel/)使用软件[chafa](https://hpjansson.org/chafa)生成。
